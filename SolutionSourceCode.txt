<?xml version="1.0" encoding="UTF-8"?>
<solution>

<file path="mcp-toolskit\Attributes\ParametersAttribute.cs">

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace mcp_toolskit.Attributes
{
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class ParametersAttribute : Attribute
    {
        public string[] ParameterDescriptions { get; }
        public ParametersAttribute(params string[] parameterDescriptions)
        {
            ParameterDescriptions = parameterDescriptions;
        }
    }
}

</file>


<file path="mcp-toolskit\Extentions\EnumExtensions.cs">

using mcp_toolskit.Attributes;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
namespace mcp_toolskit.Extentions
{
    public static class EnumExtensions
    {
        public static string GenerateFullDescription(
            this Type enumType,
            string title = &quot;Available operations&quot;)
        {
            if (!enumType.IsEnum)
            {
                throw new ArgumentException(&quot;Le type doit être une énumération&quot;, nameof(enumType));
            }
            var operations = Enum.GetValues(enumType)
                .Cast&lt;Enum&gt;()
                .Select(enumValue =&gt; {
                    var memberInfo = enumType.GetMember(enumValue.ToString()).First();
                    var description = memberInfo.GetCustomAttribute&lt;DescriptionAttribute&gt;()?.Description
                        ?? &quot;No description available&quot;;
                    var parametersDescription = memberInfo.GetCustomAttribute&lt;ParametersAttribute&gt;()?.ParameterDescriptions
                        ?? Array.Empty&lt;string&gt;();
                    var fullDescription = $&quot;- {enumValue}: {description}&quot;;
                    if (parametersDescription.Any())
                    {
                        fullDescription += &quot;\n  Parameters:\n    &quot; +
                            string.Join(&quot;\n    &quot;, parametersDescription);
                    }
                    return fullDescription;
                });
            return $&quot;{title}:\n&quot; + string.Join(&quot;\n&quot;, operations);
        }
    }
}

</file>


<file path="mcp-toolskit\Handlers\Calculator\CalculatorToolHandler.cs">

using System.ComponentModel;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
namespace mcp_toolskit.Handlers;
public class CalculatorParameters
{
    public required CalculatorOperation Operation { get; init; }
    public required double A { get; init; }
    public required double B { get; init; }
    public override string ToString()
    {
        return $&quot;Operation: {Operation}, A: {A}, B: {B}&quot;;
    }
}
[JsonConverter(typeof(JsonStringEnumConverter&lt;CalculatorOperation&gt;))]
[Description(&quot;Performs basic arithmetic operations&quot;)]
public enum CalculatorOperation
{
    [Description(&quot;Adds two numbers and returns their sum&quot;)]
    [Parameters(&quot;A: First number to add&quot;, &quot;B: Second number to add&quot;)]
    Add,
    [Description(&quot;Subtracts the second number from the first and returns the difference&quot;)]
    [Parameters(&quot;A: Starting number&quot;, &quot;B: Number to subtract&quot;)]
    Subtract,
    [Description(&quot;Multiplies two numbers and returns their product&quot;)]
    [Parameters(&quot;A: First factor&quot;, &quot;B: Second factor&quot;)]
    Multiply,
    [Description(&quot;Divides the first number by the second and returns the quotient&quot;)]
    [Parameters(&quot;A: Dividend (number to divide)&quot;, &quot;B: Divisor (non-zero)&quot;)]
    Divide,
    [Description(&quot;Raises the first number to the power of the second&quot;)]
    [Parameters(&quot;A: Base&quot;, &quot;B: Exponent&quot;)]
    Power,
    [Description(&quot;Calculates the square root of the first number&quot;)]
    [Parameters(&quot;A: Number (non-negative)&quot;, &quot;B: Not used&quot;)]
    SquareRoot,
    [Description(&quot;Calculates the remainder of dividing the first number by the second&quot;)]
    [Parameters(&quot;A: Dividend&quot;, &quot;B: Divisor (non-zero)&quot;)]
    Modulo,
    [Description(&quot;Calculates the absolute value of the first number&quot;)]
    [Parameters(&quot;A: Number to transform&quot;, &quot;B: Not used&quot;)]
    Abs,
    [Description(&quot;Calculates the logarithm of the first number with the second as base&quot;)]
    [Parameters(&quot;A: Number (strictly positive)&quot;, &quot;B: Logarithm base (strictly positive and not equal to 1)&quot;)]
    Log,
    [Description(&quot;Calculates the sine of the first number (in radians)&quot;)]
    [Parameters(&quot;A: Angle in radians&quot;, &quot;B: Not used&quot;)]
    Sin,
    [Description(&quot;Calculates the cosine of the first number (in radians)&quot;)]
    [Parameters(&quot;A: Angle in radians&quot;, &quot;B: Not used&quot;)]
    Cos,
    [Description(&quot;Calculates the tangent of the first number (in radians)&quot;)]
    [Parameters(&quot;A: Angle in radians&quot;, &quot;B: Not used&quot;)]
    Tan,
    [Description(&quot;Rounds the first number to the number of decimal places specified by the second&quot;)]
    [Parameters(&quot;A: Number to round&quot;, &quot;B: Number of decimal places (integer)&quot;)]
    Round,
    [Description(&quot;Rounds down the first number to the nearest integer&quot;)]
    [Parameters(&quot;A: Number to round&quot;, &quot;B: Not used&quot;)]
    Floor,
    [Description(&quot;Rounds up the first number to the nearest integer&quot;)]
    [Parameters(&quot;A: Number to round&quot;, &quot;B: Not used&quot;)]
    Ceiling
}
[JsonSerializable(typeof(CalculatorParameters))]
public partial class CalculatorParametersJsonContext : JsonSerializerContext { }
public class CalculatorToolHandler(
    IServerContext serverContext,
    ISessionContext sessionContext,
    ILogger&lt;CalculatorToolHandler&gt; logger
) : ToolHandlerBase&lt;CalculatorParameters&gt;(tool, serverContext, sessionContext)
{
    private static readonly Tool tool =
        new()
        {
            Name = &quot;Calculator&quot;,
            Description = typeof(CalculatorOperation).GenerateFullDescription(),
            InputSchema =
                CalculatorParametersJsonContext.Default.CalculatorParameters.GetToolSchema()!
        };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        CalculatorParametersJsonContext.Default.CalculatorParameters;
    protected override Task&lt;CallToolResult&gt; HandleAsync(
        CalculatorParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        var result = parameters.Operation switch
        {
            CalculatorOperation.Add =&gt; parameters.A + parameters.B,
            CalculatorOperation.Subtract =&gt; parameters.A - parameters.B,
            CalculatorOperation.Multiply =&gt; parameters.A * parameters.B,
            CalculatorOperation.Divide when parameters.B != 0 =&gt; parameters.A / parameters.B,
            CalculatorOperation.Divide =&gt; throw new DivideByZeroException(&quot;Cannot divide by zero&quot;),
            CalculatorOperation.Power =&gt; Math.Pow(parameters.A, parameters.B),
            CalculatorOperation.SquareRoot when parameters.A &gt;= 0 =&gt; Math.Sqrt(parameters.A),
            CalculatorOperation.SquareRoot =&gt; throw new ArgumentException(&quot;Cannot calculate square root of negative number&quot;),
            CalculatorOperation.Modulo when parameters.B != 0 =&gt; parameters.A % parameters.B,
            CalculatorOperation.Modulo =&gt; throw new DivideByZeroException(&quot;Cannot calculate modulo with zero&quot;),
            CalculatorOperation.Abs =&gt; Math.Abs(parameters.A),
            CalculatorOperation.Log when parameters.A &gt; 0 =&gt; Math.Log(parameters.A, parameters.B),
            CalculatorOperation.Log =&gt; throw new ArgumentException(&quot;Invalid logarithm parameters&quot;),
            CalculatorOperation.Sin =&gt; Math.Sin(parameters.A),
            CalculatorOperation.Cos =&gt; Math.Cos(parameters.A),
            CalculatorOperation.Tan =&gt; Math.Tan(parameters.A),
            CalculatorOperation.Round =&gt; Math.Round(parameters.A, (int)parameters.B),
            CalculatorOperation.Floor =&gt; Math.Floor(parameters.A),
            CalculatorOperation.Ceiling =&gt; Math.Ceiling(parameters.A),
            _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
        };
        var content = new TextContent { Text = result.ToString() };
        logger.LogInformation(&quot;Calculated with final content: {content}&quot;, content);
        return Task.FromResult(new CallToolResult { Content = new Annotated[] { content } });
    }
    public  Task&lt;CallToolResult&gt; TestHandleAsync(
        CalculatorParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\DotNet\DotNetToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.DotNet;
[JsonConverter(typeof(JsonStringEnumConverter&lt;DotNetOperation&gt;))]
public enum DotNetOperation
{
    [Description(&quot;Executes unit tests for a .NET solution&quot;)]
    [Parameters(&quot;SolutionFile: Full path of the solution file&quot;)]
    RunTests
}
public class DotNetParameters
{
    public required DotNetOperation Operation { get; init; }
    public required string SolutionFile { get; init; }
    public override string ToString()
    {
        return $&quot;Operation: {Operation}, SolutionFile: {SolutionFile}&quot;;
    }
}
[JsonSerializable(typeof(DotNetParameters))]
public partial class DotNetParametersJsonContext : JsonSerializerContext { }
public class DotNetToolHandler : ToolHandlerBase&lt;DotNetParameters&gt;
{
    private readonly ILogger&lt;DotNetToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public DotNetToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;DotNetToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;DotNet&quot;,
        Description = typeof(DotNetOperation).GenerateFullDescription(),
        InputSchema = DotNetParametersJsonContext.Default.DotNetParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        DotNetParametersJsonContext.Default.DotNetParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        DotNetParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Running dotnet command: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                DotNetOperation.RunTests =&gt; await RunTestsAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error running dotnet command&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; RunTestsAsync(DotNetParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.SolutionFile))
            throw new ArgumentException(&quot;SolutionFile is required for RunTests operation&quot;);
        foreach(var env in Environment.GetEnvironmentVariables().Cast&lt;DictionaryEntry&gt;())
        {
            _logger.LogDebug(&quot;Environment variable: {Key} = {Value}&quot;, env.Key, env.Value);
        }
        _logger.LogInformation(&quot;AllowedDirectories: {Directories}&quot;, string.Join(&quot;, &quot;, _appConfig.AllowedDirectories));
        _logger.LogInformation(&quot;Checking path: {Path}&quot;, Path.GetDirectoryName(parameters.SolutionFile));
        var solutionDir = _appConfig.ValidatePath(Path.GetDirectoryName(parameters.SolutionFile)!);
        if (!Directory.Exists(solutionDir))
            throw new DirectoryNotFoundException($&quot;Solution directory not found: {solutionDir}&quot;);
        var solutionPath = parameters.SolutionFile;
        if (!File.Exists(solutionPath))
            throw new FileNotFoundException($&quot;Solution file not found: {solutionPath}&quot;);
        _logger.LogInformation(&quot;Running tests for solution: {SolutionPath}&quot;, solutionPath);
        var processStartInfo = new ProcessStartInfo
        {
            FileName = &quot;dotnet&quot;,
            Arguments = $&quot;test \&quot;{solutionPath}\&quot; --no-restore --logger \&quot;trx;LogFileName=TestResults.trx\&quot;&quot;,
            WorkingDirectory = solutionDir,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        _logger.LogInformation(&quot;Starting process with: FileName = {FileName}, Arguments = {Arguments}, WorkingDirectory = {WorkingDirectory}&quot;,
            processStartInfo.FileName,
            processStartInfo.Arguments,
            processStartInfo.WorkingDirectory);
        using var process = new Process { StartInfo = processStartInfo };
        var output = new StringBuilder();
        process.OutputDataReceived += (sender, e) =&gt;
        {
            if (e.Data != null)
            {
                output.AppendLine(e.Data);
                _logger.LogInformation(&quot;Process output: {Output}&quot;, e.Data);
            }
        };
        process.ErrorDataReceived += (sender, e) =&gt;
        {
            if (e.Data != null)
            {
                var errorMessage = $&quot;ERROR: {e.Data}&quot;;
                output.AppendLine(errorMessage);
                _logger.LogError(&quot;Process error: {Error}&quot;, e.Data);
            }
        };
        process.Start();
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();
        await process.WaitForExitAsync();
        var exitCode = process.ExitCode;
        _logger.LogInformation(&quot;Process completed with exit code: {ExitCode}&quot;, exitCode);
        return output.ToString();
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\CreateDirectoryToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;CreateDirectoryOperation&gt;))]
public enum CreateDirectoryOperation
{
    [Description(&quot;Creates a new directory at a specified path&quot;)]
    [Parameters(&quot;Path: Full path of the directory to create&quot;)]
    CreateDirectory
}
public class CreateDirectoryParameters
{
    public required CreateDirectoryOperation Operation { get; init; }
    public required string Path { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);      
        return sb.ToString();
    }
}
[JsonSerializable(typeof(CreateDirectoryParameters))]
public partial class CreateDirectoryParametersJsonContext : JsonSerializerContext { }
public class CreateDirectoryToolHandler : ToolHandlerBase&lt;CreateDirectoryParameters&gt;
{
    private readonly ILogger&lt;CreateDirectoryToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public CreateDirectoryToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;CreateDirectoryToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;CreateDirectory&quot;,
        Description = typeof(CreateDirectoryOperation).GenerateFullDescription(),
        InputSchema = CreateDirectoryParametersJsonContext.Default.CreateDirectoryParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        CreateDirectoryParametersJsonContext.Default.CreateDirectoryParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        CreateDirectoryParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                CreateDirectoryOperation.CreateDirectory =&gt; await CreateDirectoryAsync(parameters),             
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; CreateDirectoryAsync(CreateDirectoryParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for CreateDirectory operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var parentDirectory = Path.GetDirectoryName(validPath);
        if (!string.IsNullOrEmpty(parentDirectory))
        {
            _appConfig.ValidatePath(parentDirectory);
            Directory.CreateDirectory(parentDirectory);
        }
        Directory.CreateDirectory(validPath);
        return await Task.FromResult($&quot;Successfully created directory {parameters.Path}&quot;);
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        CreateDirectoryParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\DeleteAtPositionToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;DeleteAtPositionOperation&gt;))]
public enum DeleteAtPositionOperation
{
    [Description(&quot;Deletes a specific number of characters at the given position&quot;)]
    [Parameters(
        &quot;Path: Full path of the file to modify&quot;,
        &quot;Position: Starting position for deletion&quot;,
        &quot;Length: Number of characters to delete&quot;,
        &quot;PreserveLength: Option to replace with spaces&quot;)]
    DeleteAtPosition
}
public class DeleteAtPositionParameters
{
    public required DeleteAtPositionOperation Operation { get; init; }
    public required string Path { get; init; }
    public required int Position { get; init; }
    public required int Length { get; init; }
    public bool PreserveLength { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        sb.Append($&quot;, Position: {Position}&quot;);
        sb.Append($&quot;, Length: {Length}&quot;);
        sb.Append($&quot;, PreserveLength: {PreserveLength}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(DeleteAtPositionParameters))]
public partial class DeleteAtPositionParametersJsonContext : JsonSerializerContext { }
public class DeleteAtPositionToolHandler : ToolHandlerBase&lt;DeleteAtPositionParameters&gt;
{
    private readonly ILogger&lt;DeleteAtPositionToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public DeleteAtPositionToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;DeleteAtPositionToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;DeleteAtPosition&quot;,
        Description = typeof(DeleteAtPositionOperation).GenerateFullDescription(),
        InputSchema = DeleteAtPositionParametersJsonContext.Default.DeleteAtPositionParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        DeleteAtPositionParametersJsonContext.Default.DeleteAtPositionParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        DeleteAtPositionParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                DeleteAtPositionOperation.DeleteAtPosition =&gt; await DeleteAtPositionAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in delete at position operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; DeleteAtPositionAsync(DeleteAtPositionParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for DeleteAtPosition operation&quot;);
        if (parameters.Length &lt;= 0)
            throw new ArgumentException(&quot;Length must be positive for DeleteAtPosition operation&quot;);
        if (parameters.Position &lt; 0)
            throw new ArgumentException(&quot;Position cannot be negative&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var content = await File.ReadAllTextAsync(validPath);
        if (parameters.Position &gt;= content.Length)
            throw new ArgumentException(&quot;Position is beyond end of file&quot;);
        var effectiveLength = Math.Min(parameters.Length, content.Length - parameters.Position);
        string newContent;
        if (parameters.PreserveLength)
        {
            var spaces = new string(&apos; &apos;, effectiveLength);
            newContent = content.Remove(parameters.Position, effectiveLength)
                              .Insert(parameters.Position, spaces);
        }
        else
        {
            newContent = content.Remove(parameters.Position, effectiveLength);
        }
        await File.WriteAllTextAsync(validPath, newContent);
        return $&quot;Successfully deleted {effectiveLength} characters at position {parameters.Position} in {parameters.Path}&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        DeleteAtPositionParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\DeleteFileToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;DeleteFileOperation&gt;))]
public enum DeleteFileOperation
{
    [Description(&quot;Deletes a file at the specified path&quot;)]
    [Parameters(&quot;Path: Full path of the file to delete&quot;)]
    DeleteFile
}
public class DeleteFileParameters
{
    public required DeleteFileOperation Operation { get; init; }
    public required string Path { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);      
        return sb.ToString();
    }
}
[JsonSerializable(typeof(DeleteFileParameters))]
public partial class DeleteFileParametersJsonContext : JsonSerializerContext { }
public class DeleteFileToolHandler : ToolHandlerBase&lt;DeleteFileParameters&gt;
{
    private readonly ILogger&lt;DeleteFileToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public DeleteFileToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;DeleteFileToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;DeleteFile&quot;,
        Description = typeof(DeleteFileOperation).GenerateFullDescription(),
        InputSchema = DeleteFileParametersJsonContext.Default.DeleteFileParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        DeleteFileParametersJsonContext.Default.DeleteFileParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        DeleteFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                DeleteFileOperation.DeleteFile =&gt; await DeleteFileAsync(parameters),             
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; DeleteFileAsync(DeleteFileParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for DeleteFile operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        if (!File.Exists(validPath))
            throw new FileNotFoundException($&quot;The file {validPath} does not exist.&quot;);
        await Task.Run(() =&gt; File.Delete(validPath));
        return $&quot;File {validPath} has been successfully deleted.&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        DeleteFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\GetFileInfoToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;GetFileInfoOperation&gt;))]
public enum GetFileInfoOperation
{
    [Description(&quot;Retrieve detailed metadata about a file or directory&quot;)]
    [Parameters(&quot;Path: Full path of the file or directory&quot;)]
    GetFileInfo
}
public class GetFileInfoParameters
{
    public required GetFileInfoOperation Operation { get; init; }
    public required string Path { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(GetFileInfoParameters))]
public partial class GetFileInfoParametersJsonContext : JsonSerializerContext { }
public class GetFileInfoToolHandler : ToolHandlerBase&lt;GetFileInfoParameters&gt;
{
    private readonly ILogger&lt;GetFileInfoToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public GetFileInfoToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;GetFileInfoToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;GetFileInfo&quot;,
        Description = typeof(GetFileInfoOperation).GenerateFullDescription(),
        InputSchema = GetFileInfoParametersJsonContext.Default.GetFileInfoParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        GetFileInfoParametersJsonContext.Default.GetFileInfoParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        GetFileInfoParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                GetFileInfoOperation.GetFileInfo =&gt; await GetFileInfoAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private Task&lt;string&gt; GetFileInfoAsync(GetFileInfoParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for GetFileInfo operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var info = new FileInfo(validPath);
        var fileInfo = new Dictionary&lt;string, string&gt;
        {
            { &quot;size&quot;, info.Length.ToString() },
            { &quot;created&quot;, info.CreationTime.ToString() },
            { &quot;modified&quot;, info.LastWriteTime.ToString() },
            { &quot;accessed&quot;, info.LastAccessTime.ToString() },
            { &quot;isDirectory&quot;, info.Attributes.HasFlag(FileAttributes.Directory).ToString() },
            { &quot;isFile&quot;, (!info.Attributes.HasFlag(FileAttributes.Directory)).ToString() },
            { &quot;permissions&quot;, Convert.ToString((int)(info.Attributes &amp; FileAttributes.Archive), 8) }
        };
        return Task.FromResult(string.Join(&quot;\n&quot;, fileInfo.Select(kvp =&gt; $&quot;{kvp.Key}: {kvp.Value}&quot;)));
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        GetFileInfoParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\ListAllowedDirectoriesToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;ListAllowedDirectoriesOperation&gt;))]
public enum ListAllowedDirectoriesOperation
{
    [Description(&quot;List all directories authorized for file operations&quot;)]
    ListAllowedDirectories
}
public class ListAllowedDirectoriesParameters
{
    public required ListAllowedDirectoriesOperation Operation { get; init; }
    public override string ToString()
    {
        return $&quot;Operation: {Operation}&quot;;
    }
}
[JsonSerializable(typeof(ListAllowedDirectoriesParameters))]
public partial class ListAllowedDirectoriesParametersJsonContext : JsonSerializerContext { }
public class ListAllowedDirectoriesToolHandler : ToolHandlerBase&lt;ListAllowedDirectoriesParameters&gt;
{
    private readonly ILogger&lt;ListAllowedDirectoriesToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public ListAllowedDirectoriesToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;ListAllowedDirectoriesToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;ListAllowedDirectories&quot;,
        Description = typeof(ListAllowedDirectoriesOperation).GenerateFullDescription(),
        InputSchema = ListAllowedDirectoriesParametersJsonContext.Default.ListAllowedDirectoriesParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        ListAllowedDirectoriesParametersJsonContext.Default.ListAllowedDirectoriesParameters;
    protected override Task&lt;CallToolResult&gt; HandleAsync(
        ListAllowedDirectoriesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                ListAllowedDirectoriesOperation.ListAllowedDirectories =&gt; ListAllowedDirectories(),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return Task.FromResult(new CallToolResult { Content = new Annotated[] { content } });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in list allowed directories operation&quot;);
            throw;
        }
    }
    private string ListAllowedDirectories()
    {
        return $&quot;Allowed directories:\n{string.Join(&quot;\n&quot;, _appConfig.AllowedDirectories)}&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        ListAllowedDirectoriesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\ListDirectoryToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;ListDirectoryOperation&gt;))]
public enum ListDirectoryOperation
{
    [Description(&quot;Lists all files and subdirectories in a specified directory&quot;)]
    [Parameters(&quot;Path: Full path of the directory to list&quot;)]
    ListDirectory
}
public class ListDirectoryParameters
{
    public required ListDirectoryOperation Operation { get; init; }
    public required string Path { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);      
        return sb.ToString();
    }
}
[JsonSerializable(typeof(ListDirectoryParameters))]
public partial class ListDirectoryParametersJsonContext : JsonSerializerContext { }
public class ListDirectoryToolHandler : ToolHandlerBase&lt;ListDirectoryParameters&gt;
{
    private readonly ILogger&lt;ListDirectoryToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public ListDirectoryToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;ListDirectoryToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;ListDirectory&quot;,
        Description = typeof(ListDirectoryOperation).GenerateFullDescription(),
        InputSchema = ListDirectoryParametersJsonContext.Default.ListDirectoryParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        ListDirectoryParametersJsonContext.Default.ListDirectoryParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        ListDirectoryParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                ListDirectoryOperation.ListDirectory =&gt; await ListDirectoryAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private Task&lt;string&gt; ListDirectoryAsync(ListDirectoryParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for ListDirectory operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var entries = Directory.GetFileSystemEntries(validPath)
            .Select(entry =&gt;
            {
                var isDirectory = Directory.Exists(entry);
                var name = Path.GetFileName(entry);
                return $&quot;{(isDirectory ? &quot;[DIR]&quot; : &quot;[FILE]&quot;)} {name}&quot;;
            });
        return Task.FromResult(string.Join(&quot;\n&quot;, entries));
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        ListDirectoryParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\MoveFileToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;MoveFileOperation&gt;))]
public enum MoveFileOperation
{
    [Description(&quot;Move or rename a file from one location to another&quot;)]
    [Parameters(
        &quot;Source: Source path of the file&quot;,
        &quot;Destination: Destination path for the file&quot;)]
    MoveFile
}
public class MoveFileParameters
{
    public required MoveFileOperation Operation { get; init; }
    public required string Source { get; init; }
    public required string Destination { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Source != null) sb.Append($&quot;, Source: {Source}&quot;);
        if (Destination != null) sb.Append($&quot;, Destination: {Destination}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(MoveFileParameters))]
public partial class MoveFileParametersJsonContext : JsonSerializerContext { }
public class MoveFileToolHandler : ToolHandlerBase&lt;MoveFileParameters&gt;
{
    private readonly ILogger&lt;MoveFileToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public MoveFileToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;MoveFileToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;MoveFile&quot;,
        Description = typeof(MoveFileOperation).GenerateFullDescription(),
        InputSchema = MoveFileParametersJsonContext.Default.MoveFileParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        MoveFileParametersJsonContext.Default.MoveFileParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        MoveFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                MoveFileOperation.MoveFile =&gt; await MoveFileAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private Task&lt;string&gt; MoveFileAsync(MoveFileParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Source))
            throw new ArgumentException(&quot;Source path is required for MoveFile operation&quot;);
        if (string.IsNullOrEmpty(parameters.Destination))
            throw new ArgumentException(&quot;Destination path is required for MoveFile operation&quot;);
        var validSourcePath = _appConfig.ValidatePath(parameters.Source);
        var validDestPath = _appConfig.ValidatePath(parameters.Destination);
        File.Move(validSourcePath, validDestPath);
        return Task.FromResult($&quot;Successfully moved {parameters.Source} to {parameters.Destination}&quot;);
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        MoveFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\ReadFileToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;ReadFileOperation&gt;))]
public enum ReadFileOperation
{
    [Description(&quot;Reads the content of a file from a specified path&quot;)]
    [Parameters(&quot;Path: Full path of the file to read&quot;)]
    ReadFile
}
public class ReadFileParameters
{
    public required ReadFileOperation Operation { get; init; }
    public required string Path { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);      
        return sb.ToString();
    }
}
[JsonSerializable(typeof(ReadFileParameters))]
public partial class ReadFileParametersJsonContext : JsonSerializerContext { }
public class ReadFileToolHandler : ToolHandlerBase&lt;ReadFileParameters&gt;
{
    private readonly ILogger&lt;ReadFileToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public ReadFileToolHandler(
    IServerContext serverContext,
    ISessionContext sessionContext,
    ILogger&lt;ReadFileToolHandler&gt; logger,
    AppConfig appConfig
) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;ReadFile&quot;,
        Description = typeof(ReadFileOperation).GenerateFullDescription(),
        InputSchema = ReadFileParametersJsonContext.Default.ReadFileParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
       ReadFileParametersJsonContext.Default.ReadFileParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        ReadFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                ReadFileOperation.ReadFile =&gt; await ReadFileAsync(parameters),             
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; ReadFileAsync(ReadFileParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for ReadFile operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        return await File.ReadAllTextAsync(validPath);
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        ReadFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\ReadMultipleFilesToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;ReadMultipleFilesOperation&gt;))]
public enum ReadMultipleFilesOperation
{
    [Description(&quot;Reads the contents of multiple files from specified paths&quot;)]
    [Parameters(&quot;Paths: List of full paths of files to read&quot;)]
    ReadMultipleFiles
}
public class ReadMultipleFilesParameters
{
    public required ReadMultipleFilesOperation Operation { get; init; }
    public required List&lt;string&gt; Paths { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Paths != null) sb.Append($&quot;, Paths: [{string.Join(&quot;, &quot;, Paths)}]&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(ReadMultipleFilesParameters))]
public partial class ReadMultipleFilesParametersJsonContext : JsonSerializerContext { }
public class ReadMultipleFilesToolHandler : ToolHandlerBase&lt;ReadMultipleFilesParameters&gt;
{
    private readonly ILogger&lt;ReadMultipleFilesToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public ReadMultipleFilesToolHandler(
    IServerContext serverContext,
    ISessionContext sessionContext,
    ILogger&lt;ReadMultipleFilesToolHandler&gt; logger,
    AppConfig appConfig
) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;ReadMultipleFiles&quot;,
        Description = typeof(ReadMultipleFilesOperation).GenerateFullDescription(),
        InputSchema = ReadMultipleFilesParametersJsonContext.Default.ReadMultipleFilesParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
       ReadMultipleFilesParametersJsonContext.Default.ReadMultipleFilesParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        ReadMultipleFilesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                ReadMultipleFilesOperation.ReadMultipleFiles =&gt; await ReadMultipleFilesAsync(parameters),             
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; ReadMultipleFilesAsync(ReadMultipleFilesParameters parameters)
    {
        if (parameters.Paths == null || !parameters.Paths.Any())
            throw new ArgumentException(&quot;Paths are required for ReadMultipleFiles operation&quot;);
        var results = new List&lt;string&gt;();
        foreach (var path in parameters.Paths)
        {
            try
            {
                var validPath = _appConfig.ValidatePath(path);
                var content = await File.ReadAllTextAsync(validPath);
                results.Add($&quot;{path}:\n{content}&quot;);
            }
            catch (Exception ex)
            {
                results.Add($&quot;{path}: Error - {ex.Message}&quot;);
            }
        }
        return string.Join(&quot;\n---\n&quot;, results);
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        ReadMultipleFilesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\SearchAndReplaceToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;SearchAndReplaceOperation&gt;))]
public enum SearchAndReplaceOperation
{
    [Description(&quot;Replaces occurrences of a regular expression with replacement content&quot;)]
    [Parameters(
        &quot;Path: Full path of the file to modify&quot;,
        &quot;Regex: Regular expression pattern to search for&quot;,
        &quot;Replacement: Replacement content&quot;,
        &quot;PreserveLength: Option to preserve file length&quot;)]
    SearchAndReplace
}
public class SearchAndReplaceParameters
{
    public required SearchAndReplaceOperation Operation { get; init; }
    public required string Path { get; init; }
    public required string Regex { get; init; }
    public required string Replacement { get; init; }
    public bool PreserveLength { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        if (Regex != null) sb.Append($&quot;, Regex: {Regex}&quot;);
        if (Replacement != null) sb.Append($&quot;, Replacement: {Replacement}&quot;);
        sb.Append($&quot;, PreserveLength: {PreserveLength}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(SearchAndReplaceParameters))]
public partial class SearchAndReplaceParametersJsonContext : JsonSerializerContext { }
public class SearchAndReplaceToolHandler : ToolHandlerBase&lt;SearchAndReplaceParameters&gt;
{
    private readonly ILogger&lt;SearchAndReplaceToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public SearchAndReplaceToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;SearchAndReplaceToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;SearchAndReplace&quot;,
        Description = typeof(SearchAndReplaceOperation).GenerateFullDescription(),
        InputSchema = SearchAndReplaceParametersJsonContext.Default.SearchAndReplaceParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        SearchAndReplaceParametersJsonContext.Default.SearchAndReplaceParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        SearchAndReplaceParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                SearchAndReplaceOperation.SearchAndReplace =&gt; await SearchAndReplaceAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in search and replace operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; SearchAndReplaceAsync(SearchAndReplaceParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for SearchAndReplace operation&quot;);
        if (string.IsNullOrEmpty(parameters.Regex))
            throw new ArgumentException(&quot;Regex pattern is required for SearchAndReplace operation&quot;);
        if (string.IsNullOrEmpty(parameters.Replacement))
            throw new ArgumentException(&quot;Replacement content is required for SearchAndReplace operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var content = await File.ReadAllTextAsync(validPath);
        var regex = new System.Text.RegularExpressions.Regex(parameters.Regex);
        var matches = regex.Matches(content);
        if (!matches.Any())
            return &quot;No matches found&quot;;
        string newContent;
        if (parameters.PreserveLength)
        {
            newContent = content;
            foreach (System.Text.RegularExpressions.Match match in matches.Reverse()) 
            {
                var replacement = parameters.Replacement.PadRight(match.Length);
                if (replacement.Length &gt; match.Length)
                    replacement = replacement.Substring(0, match.Length);
                newContent = newContent.Remove(match.Index, match.Length)
                                     .Insert(match.Index, replacement);
            }
        }
        else
        {
            newContent = regex.Replace(content, parameters.Replacement);
        }
        await File.WriteAllTextAsync(validPath, newContent);
        return $&quot;Successfully replaced {matches.Count} occurrences in {parameters.Path}&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        SearchAndReplaceParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\SearchFilesToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;SearchFilesOperation&gt;))]
public enum SearchFilesOperation
{
    [Description(&quot;Search for files matching a pattern in a directory&quot;)]
    [Parameters(
        &quot;Path: Directory to search in&quot;,
        &quot;Pattern: Search pattern for files&quot;)]
    SearchFiles
}
public class SearchFilesParameters
{
    public required SearchFilesOperation Operation { get; init; }
    public required string Path { get; init; }
    public required string Pattern { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        if (Pattern != null) sb.Append($&quot;, Pattern: {Pattern}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(SearchFilesParameters))]
public partial class SearchFilesParametersJsonContext : JsonSerializerContext { }
public class SearchFilesToolHandler : ToolHandlerBase&lt;SearchFilesParameters&gt;
{
    private readonly ILogger&lt;SearchFilesToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public SearchFilesToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;SearchFilesToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;SearchFiles&quot;,
        Description = typeof(SearchFilesOperation).GenerateFullDescription(),
        InputSchema = SearchFilesParametersJsonContext.Default.SearchFilesParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        SearchFilesParametersJsonContext.Default.SearchFilesParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        SearchFilesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                SearchFilesOperation.SearchFiles =&gt; await SearchFilesAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in search files operation&quot;);
            throw;
        }
    }
    private Task&lt;string&gt; SearchFilesAsync(SearchFilesParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for SearchFiles operation&quot;);
        if (string.IsNullOrEmpty(parameters.Pattern))
            throw new ArgumentException(&quot;Pattern is required for SearchFiles operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var results = Directory.GetFiles(validPath, $&quot;*{parameters.Pattern}*&quot;, SearchOption.AllDirectories)
            .Where(file =&gt;
            {
                try
                {
                    _appConfig.ValidatePath(file);
                    return true;
                }
                catch
                {
                    return false;
                }
            });
        var fileList = results.ToList();
        return Task.FromResult(fileList.Any()
            ? string.Join(&quot;\n&quot;, fileList)
            : &quot;No matches found&quot;);
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        SearchFilesParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\SearchPositionInFileWithRegexToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Text.RegularExpressions;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;SearchPositionInFileWithRegexOperation&gt;))]
public enum SearchPositionInFileWithRegexOperation
{
    [Description(&quot;Searches for positions of regex pattern matches in a file&quot;)]
    [Parameters(
        &quot;Path: Full path of the file to examine&quot;,
        &quot;Regex: Regular expression pattern to search for&quot;)]
    SearchPositionInFileWithRegex
}
public class SearchPositionInFileWithRegexParameters
{
    public required SearchPositionInFileWithRegexOperation Operation { get; init; }
    public required string Path { get; init; }
    public required string Regex { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        if (Regex != null) sb.Append($&quot;, Regex: {Regex}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(SearchPositionInFileWithRegexParameters))]
public partial class SearchPositionInFileWithRegexParametersJsonContext : JsonSerializerContext { }
public class SearchPositionInFileWithRegexToolHandler : ToolHandlerBase&lt;SearchPositionInFileWithRegexParameters&gt;
{
    private readonly ILogger&lt;SearchPositionInFileWithRegexToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public SearchPositionInFileWithRegexToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;SearchPositionInFileWithRegexToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;SearchPositionInFileWithRegex&quot;,
        Description = typeof(SearchPositionInFileWithRegexOperation).GenerateFullDescription(),
        InputSchema = SearchPositionInFileWithRegexParametersJsonContext.Default.SearchPositionInFileWithRegexParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        SearchPositionInFileWithRegexParametersJsonContext.Default.SearchPositionInFileWithRegexParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        SearchPositionInFileWithRegexParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                SearchPositionInFileWithRegexOperation.SearchPositionInFileWithRegex =&gt; await SearchPositionInFileWithRegexAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in regex search operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; SearchPositionInFileWithRegexAsync(SearchPositionInFileWithRegexParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for SearchPositionInFileWithRegex operation&quot;);
        if (string.IsNullOrEmpty(parameters.Regex))
            throw new ArgumentException(&quot;Regex pattern is required for SearchPositionInFileWithRegex operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var content = await File.ReadAllTextAsync(validPath);
        var regex = new Regex(parameters.Regex);
        var matches = regex.Matches(content);
        if (!matches.Any())
            return &quot;No matches found&quot;;
        var results = matches.Select(match =&gt; new
        {
            Position = match.Index,
            Length = match.Length,
            Value = match.Value
        });
        return string.Join(&quot;\n&quot;, results.Select(r =&gt;
            $&quot;Position: {r.Position}, Length: {r.Length}, Value: {r.Value}&quot;));
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        SearchPositionInFileWithRegexParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\WriteFileAtPositionToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;WriteFileAtPositionOperation&gt;))]
public enum WriteFileAtPositionOperation
{
    [Description(&quot;Insert content into a file at a specific position&quot;)]
    [Parameters(
        &quot;Path: Full path of the file to modify&quot;,
        &quot;Content: Content to insert&quot;,
        &quot;Position: Insertion position in the file&quot;)]
    WriteFileAtPosition
}
public class WriteFileAtPositionParameters
{
    public required WriteFileAtPositionOperation Operation { get; init; }
    public required string Path { get; init; }
    public required string Content { get; init; }
    public required int Position { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        sb.Append($&quot;, Path: {Path}&quot;);
        sb.Append($&quot;, Content Length: {Content?.Length ?? 0}&quot;);
        sb.Append($&quot;, Position: {Position}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(WriteFileAtPositionParameters))]
public partial class WriteFileAtPositionParametersJsonContext : JsonSerializerContext { }
public class WriteFileAtPositionToolHandler : ToolHandlerBase&lt;WriteFileAtPositionParameters&gt;
{
    private readonly ILogger&lt;WriteFileAtPositionToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public WriteFileAtPositionToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;WriteFileAtPositionToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;WriteFileAtPosition&quot;,
        Description = typeof(WriteFileAtPositionOperation).GenerateFullDescription(),
        InputSchema = WriteFileAtPositionParametersJsonContext.Default.WriteFileAtPositionParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        WriteFileAtPositionParametersJsonContext.Default.WriteFileAtPositionParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        WriteFileAtPositionParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                WriteFileAtPositionOperation.WriteFileAtPosition =&gt; await WriteFileAtPositionAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in write file at position operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; WriteFileAtPositionAsync(WriteFileAtPositionParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for WriteFileAtPosition operation&quot;);
        if (string.IsNullOrEmpty(parameters.Content))
            throw new ArgumentException(&quot;Content is required for WriteFileAtPosition operation&quot;);
        if (parameters.Position &lt; 0)
            throw new ArgumentException(&quot;Position cannot be negative&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        var directory = Path.GetDirectoryName(validPath);
        if (!string.IsNullOrEmpty(directory) &amp;&amp; !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        string existingContent = &quot;&quot;;
        if (File.Exists(validPath))
        {
            existingContent = await File.ReadAllTextAsync(validPath);
        }
        string newContent;
        if (parameters.Position &gt; existingContent.Length)
        {
            newContent = existingContent.PadRight(parameters.Position) + parameters.Content;
        }
        else if (parameters.Position == 0)
        {
            if (existingContent.StartsWith(parameters.Content))
            {
                newContent = existingContent;
            }
            else
            {
                newContent = parameters.Content +
                     (existingContent.Length &gt; parameters.Content.Length
                         ? existingContent.Substring(parameters.Content.Length)
                         : &quot;&quot;);
            }
        }
        else
        {
            newContent = existingContent.Substring(0, parameters.Position) +
                         parameters.Content +
                         existingContent.Substring(parameters.Position);
        }
        await File.WriteAllTextAsync(validPath, newContent);
        return $&quot;Successfully wrote content at position {parameters.Position} in {parameters.Path}&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        WriteFileAtPositionParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Handlers\Filesystem\WriteFileToolHandler.cs">

using mcp_toolskit.Attributes;
using mcp_toolskit.Extentions;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Server.Features.Tools;
using System.ComponentModel;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
namespace mcp_toolskit.Handlers.Filesystem;
[JsonConverter(typeof(JsonStringEnumConverter&lt;WriteFileOperation&gt;))]
public enum WriteFileOperation
{
    [Description(&quot;Writes content to a file, overwriting existing content&quot;)]
    [Parameters(
        &quot;Path: Complete path of the file to write&quot;,
        &quot;Content: Content to write to the file&quot;)]
    WriteFile
}
public class WriteFileParameters
{
    public required WriteFileOperation Operation { get; init; }
    public required string Path { get; init; }
    public required string Content { get; init; }
    public override string ToString()
    {
        var sb = new StringBuilder($&quot;Operation: {Operation}&quot;);
        if (Path != null) sb.Append($&quot;, Path: {Path}&quot;);
        if (Content != null) sb.Append($&quot;, Content length: {Content.Length}&quot;);
        return sb.ToString();
    }
}
[JsonSerializable(typeof(WriteFileParameters))]
public partial class WriteFileParametersJsonContext : JsonSerializerContext { }
public class WriteFileToolHandler : ToolHandlerBase&lt;WriteFileParameters&gt;
{
    private readonly ILogger&lt;WriteFileToolHandler&gt; _logger;
    private readonly AppConfig _appConfig;
    public WriteFileToolHandler(
        IServerContext serverContext,
        ISessionContext sessionContext,
        ILogger&lt;WriteFileToolHandler&gt; logger,
        AppConfig appConfig
    ) : base(tool, serverContext, sessionContext)
    {
        _logger = logger;
        _appConfig = appConfig;
    }
    private static readonly Tool tool = new()
    {
        Name = &quot;WriteFile&quot;,
        Description = typeof(WriteFileOperation).GenerateFullDescription(),
        InputSchema = WriteFileParametersJsonContext.Default.WriteFileParameters.GetToolSchema()!
    };
    public override JsonTypeInfo JsonTypeInfo =&gt;
        WriteFileParametersJsonContext.Default.WriteFileParameters;
    protected override async Task&lt;CallToolResult&gt; HandleAsync(
        WriteFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        _logger.LogInformation(&quot;Query: {parameters}&quot;, parameters.ToString());
        try
        {
            string result = parameters.Operation switch
            {
                WriteFileOperation.WriteFile =&gt; await WriteFileAsync(parameters),
                _ =&gt; throw new ArgumentException($&quot;Unknown operation: {parameters.Operation}&quot;)
            };
            var content = new TextContent { Text = result };
            return new CallToolResult { Content = new Annotated[] { content } };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error in filesystem operation&quot;);
            throw;
        }
    }
    private async Task&lt;string&gt; WriteFileAsync(WriteFileParameters parameters)
    {
        if (string.IsNullOrEmpty(parameters.Path))
            throw new ArgumentException(&quot;Path is required for WriteFile operation&quot;);
        if (string.IsNullOrEmpty(parameters.Content))
            throw new ArgumentException(&quot;Content is required for WriteFile operation&quot;);
        var validPath = _appConfig.ValidatePath(parameters.Path);
        await File.WriteAllTextAsync(validPath, parameters.Content);
        return $&quot;Successfully wrote to {parameters.Path}&quot;;
    }
    public Task&lt;CallToolResult&gt; TestHandleAsync(
        WriteFileParameters parameters,
        CancellationToken cancellationToken = default
    )
    {
        return HandleAsync(parameters, cancellationToken);
    }
}

</file>


<file path="mcp-toolskit\Models\AppConfig.cs">

using System;
using System.Text.Json;
namespace mcp_toolskit.Models
{
    public class AppConfig
    {
        public string LogPath { get; set; } = AppContext.BaseDirectory;
        public string[] AllowedDirectories { get; set; } = Array.Empty&lt;string&gt;();
        public string[] ForbiddenTools { get; set; } = Array.Empty&lt;string&gt;();
        public AppConfig()
        {
            NormalizePathProperties();
        }
        private void NormalizePathProperties()
        {
            if (!string.IsNullOrWhiteSpace(LogPath))
            {
                LogPath = Path.GetFullPath(LogPath, AppContext.BaseDirectory);
            }
            if (AllowedDirectories != null)
            {
                AllowedDirectories = AllowedDirectories.Select(dir =&gt;
                    Path.GetFullPath(dir, AppContext.BaseDirectory)).ToArray();
            }
        }
        public static AppConfig LoadFromFile(string path)
        {
            if (!File.Exists(path))
                throw new FileNotFoundException(&quot;Le fichier de configuration n&apos;existe pas.&quot;, path);
            string jsonContent = File.ReadAllText(path);
            var config = JsonSerializer.Deserialize&lt;AppConfig&gt;(jsonContent) ?? new AppConfig();
            config.NormalizePathProperties();
            return config;
        }
        public static AppConfig GetConfiguration(string? configPath, out string? errorMessage)
        {
            errorMessage = null;
            if (string.IsNullOrWhiteSpace(configPath))
            {
                configPath = Path.Combine(AppContext.BaseDirectory, &quot;config.json&quot;);
            }
            try
            {
                return LoadFromFile(configPath);
            }
            catch (FileNotFoundException)
            {
                if (configPath == Path.Combine(AppContext.BaseDirectory, &quot;config.json&quot;))
                {
                    return new AppConfig();
                }
                errorMessage = $&quot;Le fichier de configuration &apos;{configPath}&apos; n&apos;existe pas. Utilisation de la configuration par défaut.&quot;;
            }
            catch (JsonException ex)
            {
                errorMessage = $&quot;Erreur de format dans le fichier de configuration &apos;{configPath}&apos;: {ex.Message}. Utilisation de la configuration par défaut.&quot;;
            }
            catch (Exception ex)
            {
                errorMessage = $&quot;Erreur lors du chargement de la configuration &apos;{configPath}&apos;: {ex.Message}. Utilisation de la configuration par défaut.&quot;;
            }
            return new AppConfig();
        }
        public override string ToString()
        {
            return JsonSerializer.Serialize(this, new JsonSerializerOptions 
            { 
                WriteIndented = true 
            });
        }
        public virtual string ValidatePath(string path)
        {
            var fullPath = Path.GetFullPath(path);
            if (!AllowedDirectories.Any(dir =&gt; fullPath.StartsWith(Path.GetFullPath(dir))))
            {
                throw new UnauthorizedAccessException($&quot;Access denied - path outside allowed directories: {fullPath}&quot;);
            }
            return fullPath;
        }
        public virtual bool ValidateTool(string tool_name)
        {
            if (ForbiddenTools.Any(tool =&gt; tool?.ToLower() == tool_name?.ToLower()))
            {
                return false;
            }
            return true;
        }
    }
}

</file>


<file path="mcp-toolskit\Program.cs">

using mcp_toolskit.Handlers;
using mcp_toolskit.Handlers.DotNet;
using mcp_toolskit.Handlers.Filesystem;
using mcp_toolskit.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Server.Builder;
using Serilog;
namespace mcp_toolskit
{
    internal class Program
    {
        public static string GetCurrentLogFileName(string logPath)
        {
            string baseFileName = &quot;Logs&quot;;
            string date = DateTime.Now.ToString(&quot;yyyyMMdd&quot;);
            return Path.Combine(logPath, $&quot;{baseFileName}{date}.txt&quot;);
        }
        static async Task Main(string[] args)
        {
            string? errorMessage;
            var appConfig = AppConfig.GetConfiguration(args.Length &gt; 0 ? args[0] : null, out errorMessage);
            if (errorMessage != null)
            {
                Console.Error.WriteLine(errorMessage);
            }
            Console.Error.WriteLine(&quot;Configuration chargée :&quot;);
            Console.Error.WriteLine(appConfig.ToString());
            string version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? &quot;Version inconnue&quot;;
            var serverInfo = new Implementation { Name = &quot;La boîte à outils de Toto&quot;, Version = version };
            var seriLogger = new LoggerConfiguration()
                .WriteTo.File(Path.Combine(appConfig.LogPath,&quot;Logs.txt&quot;), 
                              rollingInterval: RollingInterval.Day, 
                              retainedFileCountLimit: 7)
                .MinimumLevel.Debug()
                .CreateLogger();
            Log.Logger = seriLogger;
            var server = new McpServerBuilder(serverInfo)
                .AddStdioTransport()
                .ConfigureLogging(logging =&gt; logging.AddSerilog(seriLogger).SetMinimumLevel(LogLevel.Trace))
                .ConfigureUserServices(services =&gt;
                {
                    services.AddLogging(builder =&gt;
                    {
                        builder.ClearProviders();
                        builder.AddSerilog(seriLogger, dispose: true);
                        builder.SetMinimumLevel(LogLevel.Debug);
                    });
                    services.AddSingleton(appConfig);
                })
                .ConfigureTools(tools =&gt; {
                    if (appConfig.ValidateTool(&quot;ListAllowedDirectories&quot;))
                        tools.AddHandler&lt;ListAllowedDirectoriesToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;ReadFile&quot;))
                        tools.AddHandler&lt;ReadFileToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;ReadMultipleFiles&quot;))
                        tools.AddHandler&lt;ReadMultipleFilesToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;WriteFile&quot;))
                        tools.AddHandler&lt;WriteFileToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;WriteFileAtPosition&quot;))
                        tools.AddHandler&lt;WriteFileAtPositionToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;CreateDirectory&quot;))
                        tools.AddHandler&lt;CreateDirectoryToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;ListDirectory&quot;))
                        tools.AddHandler&lt;ListDirectoryToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;MoveFile&quot;))
                        tools.AddHandler&lt;MoveFileToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;SearchFiles&quot;))
                        tools.AddHandler&lt;SearchFilesToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;SearchPositionInFileWithRegex&quot;))
                        tools.AddHandler&lt;SearchPositionInFileWithRegexToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;GetFileInfo&quot;))
                        tools.AddHandler&lt;GetFileInfoToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;DeleteAtPosition&quot;))
                        tools.AddHandler&lt;DeleteAtPositionToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;SearchAndReplace&quot;))
                        tools.AddHandler&lt;SearchAndReplaceToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;DeleteFile&quot;))
                        tools.AddHandler&lt;DeleteFileToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;DotNet&quot;))
                        tools.AddHandler&lt;DotNetToolHandler&gt;();
                    if (appConfig.ValidateTool(&quot;Calculator&quot;))
                        tools.AddHandler&lt;CalculatorToolHandler&gt;();
                })
                .Build();
            try
            {
                server.Start();
                Console.Error.WriteLine($&quot;Serveur MCP &apos;{serverInfo.Name}&apos; v{serverInfo.Version} s&apos;exécutant sur stdio&quot;);
                string currentLogFile = GetCurrentLogFileName(appConfig.LogPath);
                Console.Error.WriteLine($&quot;Fichier de log actuel : {currentLogFile}&quot;);
                await Task.Delay(-1); 
            }
            finally
            {
                server.Stop();
                await server.DisposeAsync();
                Log.CloseAndFlush(); 
            }
        }
    }
}

</file>


<file path="mcp-toolskit-tests\TestHandlers\DotNet\DotNetToolHandlerTests.cs">

using mcp_toolskit.Handlers.DotNet;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Core.Models.Protocol.Client.Responses;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Contexts;
using Moq;
using System.Text.RegularExpressions;
namespace mcp_toolskit_tests.TestHandlers.DotNet
{
    public class TestDotNetToolHandler
    {
        private readonly Mock&lt;IServerContext&gt; _mockServerContext;
        private readonly Mock&lt;ISessionContext&gt; _mockSessionContext;
        private readonly Mock&lt;ILogger&lt;DotNetToolHandler&gt;&gt; _mockLogger;
        private readonly TestAppConfig _appConfig;
        private readonly DotNetToolHandler _handler;
        private readonly string _testBasePath = Path.Combine(Path.GetTempPath(), &quot;mcp-toolskit-tests&quot;, &quot;dotnet&quot;);
        public class TestAppConfig : AppConfig
        {
            public override string ValidatePath(string path)
            {
                return Path.GetFullPath(path);
            }
        }
        public TestDotNetToolHandler()
        {
            _mockServerContext = new Mock&lt;IServerContext&gt;();
            _mockSessionContext = new Mock&lt;ISessionContext&gt;();
            _mockLogger = new Mock&lt;ILogger&lt;DotNetToolHandler&gt;&gt;();
            _appConfig = new TestAppConfig();
            _handler = new DotNetToolHandler(
                _mockServerContext.Object,
                _mockSessionContext.Object,
                _mockLogger.Object,
                _appConfig
            );
            Directory.CreateDirectory(_testBasePath);
        }
        [Fact]
        public async Task RunTests_WithValidSolutionFile_ShouldReturnTestResults()
        {
            var tempSolutionFile = Path.Combine(_testBasePath, &quot;TestSolution.sln&quot;);
            File.WriteAllText(tempSolutionFile, &quot;Mock Solution File&quot;);
            var parameters = new DotNetParameters
            {
                Operation = DotNetOperation.RunTests,
                SolutionFile = tempSolutionFile
            };
            try 
            {
                var result = await InvokeHandleAsync(parameters);
                Assert.NotNull(result);
                Assert.NotNull(result.Content);
                Assert.True(result.Content.Length &gt; 0);
                var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
                Assert.NotNull(textContent.Text);
                _mockLogger.Verify(
                    x =&gt; x.Log(
                        LogLevel.Information, 
                        It.IsAny&lt;EventId&gt;(), 
                        It.Is&lt;It.IsAnyType&gt;((v, t) =&gt; v.ToString().Contains(&quot;Running dotnet command&quot;)),
                        null, 
                        It.IsAny&lt;Func&lt;It.IsAnyType, Exception, string&gt;&gt;()
                    ), 
                    Times.AtLeastOnce()
                );
            }
            finally 
            {
                if (File.Exists(tempSolutionFile))
                    File.Delete(tempSolutionFile);
            }
        }
        [Theory]
        [InlineData(null)]
        [InlineData(&quot;&quot;)]
        public async Task RunTests_WithInvalidSolutionFile_ShouldThrowArgumentException(string invalidPath)
        {
            var parameters = new DotNetParameters
            {
                Operation = DotNetOperation.RunTests,
                SolutionFile = invalidPath
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await InvokeHandleAsync(parameters)
            );
        }
        [Fact]
        public async Task RunTests_WithNonExistentPath_ShouldThrowDirectoryNotFoundException()
        {
            var nonExistentPath = Path.Combine(_testBasePath, &quot;nonexistent&quot;, &quot;Solution.sln&quot;);
            var parameters = new DotNetParameters
            {
                Operation = DotNetOperation.RunTests,
                SolutionFile = nonExistentPath
            };
            await Assert.ThrowsAsync&lt;DirectoryNotFoundException&gt;(
                async () =&gt; await InvokeHandleAsync(parameters)
            );
        }
        [Fact]
        public async Task RunTests_WithInvalidOperation_ShouldThrowArgumentException()
        {
            var parameters = new DotNetParameters
            {
                Operation = (DotNetOperation)999, 
                SolutionFile = Path.Combine(_testBasePath, &quot;TestSolution.sln&quot;)
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await InvokeHandleAsync(parameters)
            );
        }
        private async Task&lt;CallToolResult&gt; InvokeHandleAsync(DotNetParameters parameters)
        {
            var method = typeof(DotNetToolHandler)
                .GetMethod(&quot;HandleAsync&quot;, 
                    System.Reflection.BindingFlags.NonPublic | 
                    System.Reflection.BindingFlags.Instance);
            if (method == null)
                throw new InvalidOperationException(&quot;Method HandleAsync not found&quot;);
            return await (Task&lt;CallToolResult&gt;)method.Invoke(_handler, new object[] { parameters, CancellationToken.None });
        }
        public void Dispose()
        {
            if (Directory.Exists(_testBasePath))
                Directory.Delete(_testBasePath, true);
        }
    }
}

</file>


<file path="mcp-toolskit-tests\TestHandlers\Filesystem\CreateDirectoryToolHandler.cs">

using mcp_toolskit.Handlers.Filesystem;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Server.Features.Tools;
using Moq;
namespace mcp_toolskit_tests.TestHandlers.Filesystem
{
    public class TestCreateDirectoryToolHandler
    {
        private readonly Mock&lt;IServerContext&gt; _mockServerContext;
        private readonly Mock&lt;ISessionContext&gt; _mockSessionContext;
        private readonly Mock&lt;ILogger&lt;CreateDirectoryToolHandler&gt;&gt; _mockLogger;
        private readonly TestAppConfig _appConfig;
        private readonly CreateDirectoryToolHandler _handler;
        private readonly string _testBasePath = Path.Combine(Path.GetTempPath(), &quot;mcp-toolskit-tests&quot;);
        public class TestAppConfig : AppConfig
        {
            public override string ValidatePath(string path)
            {
                return Path.GetFullPath(path);
            }
        }
        public TestCreateDirectoryToolHandler()
        {
            _mockServerContext = new Mock&lt;IServerContext&gt;();
            _mockSessionContext = new Mock&lt;ISessionContext&gt;();
            _mockLogger = new Mock&lt;ILogger&lt;CreateDirectoryToolHandler&gt;&gt;();
            _appConfig = new TestAppConfig();
            _handler = new CreateDirectoryToolHandler(
                _mockServerContext.Object,
                _mockSessionContext.Object,
                _mockLogger.Object,
                _appConfig
            );
            Directory.CreateDirectory(_testBasePath);
        }
        [Theory]
        [InlineData(&quot;testDir1&quot;)]
        [InlineData(&quot;path/to/nested/directory&quot;)]
        [InlineData(&quot;path\\to\\nested\\directory2&quot;)]
        [InlineData(&quot;directory with spaces&quot;)]
        public async Task CreateDirectory_ShouldCreateDirectory(string directoryPath)
        {
            var relativePath = Path.Combine(_testBasePath, directoryPath);
            var parameters = new CreateDirectoryParameters
            {
                Operation = CreateDirectoryOperation.CreateDirectory,
                Path = relativePath
            };
            if (Directory.Exists(relativePath))
                Directory.Delete(relativePath, true);
            try
            {
                var result = await _handler.TestHandleAsync(parameters, default);
                Assert.NotNull(result);
                Assert.True(result.Content.Length &gt; 0);
                var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
                Assert.Contains($&quot;Successfully created directory {relativePath}&quot;, textContent.Text);
                Assert.True(Directory.Exists(relativePath));
            }
            finally
            {
                if (Directory.Exists(relativePath))
                    Directory.Delete(relativePath, true);
            }
        }
        [Theory]
        [InlineData(&quot;&quot;)]
        [InlineData(null)]
        public async Task CreateDirectory_WithInvalidPath_ShouldThrowArgumentException(string directoryPath)
        {
            var parameters = new CreateDirectoryParameters
            {
                Operation = CreateDirectoryOperation.CreateDirectory,
                Path = directoryPath
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Fact]
        public async Task CreateDirectory_WithInvalidOperation_ShouldThrowArgumentException()
        {
            var parameters = new CreateDirectoryParameters
            {
                Operation = (CreateDirectoryOperation)999, 
                Path = Path.Combine(_testBasePath, &quot;test&quot;)
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        public void Dispose()
        {
            if (Directory.Exists(_testBasePath))
                Directory.Delete(_testBasePath, true);
        }
    }
}

</file>


<file path="mcp-toolskit-tests\TestHandlers\Filesystem\DeleteAtPositionToolHandler.cs">

using mcp_toolskit.Handlers.Filesystem;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Server.Features.Tools;
using Moq;
namespace mcp_toolskit_tests.TestHandlers.Filesystem
{
    public class TestDeleteAtPositionToolHandler : IDisposable
    {
        private readonly Mock&lt;IServerContext&gt; _mockServerContext;
        private readonly Mock&lt;ISessionContext&gt; _mockSessionContext;
        private readonly Mock&lt;ILogger&lt;DeleteAtPositionToolHandler&gt;&gt; _mockLogger;
        private readonly AppConfig _appConfig;
        private readonly DeleteAtPositionToolHandler _handler;
        private readonly string _testBasePath = Path.Combine(Path.GetTempPath(), &quot;mcp-toolskit-tests&quot;);
        private readonly string _testFilePath;
        public TestDeleteAtPositionToolHandler()
        {
            _mockServerContext = new Mock&lt;IServerContext&gt;();
            _mockSessionContext = new Mock&lt;ISessionContext&gt;();
            _mockLogger = new Mock&lt;ILogger&lt;DeleteAtPositionToolHandler&gt;&gt;();
            _appConfig = new AppConfig 
            { 
                AllowedDirectories = new string[] { _testBasePath }
            };
            _handler = new DeleteAtPositionToolHandler(
                _mockServerContext.Object,
                _mockSessionContext.Object,
                _mockLogger.Object,
                _appConfig
            );
            Directory.CreateDirectory(_testBasePath);
            _testFilePath = Path.Combine(_testBasePath, &quot;test.txt&quot;);
        }
        [Theory]
        [InlineData(&quot;Hello World!&quot;, 6, 5, false, &quot;Hello !&quot;)] 
        [InlineData(&quot;Hello World!&quot;, 6, 5, true, &quot;Hello      !&quot;)] 
        [InlineData(&quot;Test Content&quot;, 0, 4, false, &quot; Content&quot;)] 
        public async Task DeleteAtPosition_ShouldModifyFileCorrectly(
            string initialContent,
            int position,
            int length,
            bool preserveLength,
            string expectedContent)
        {
            await File.WriteAllTextAsync(_testFilePath, initialContent);
            var parameters = new DeleteAtPositionParameters
            {
                Operation = DeleteAtPositionOperation.DeleteAtPosition,
                Path = _testFilePath,
                Position = position,
                Length = length,
                PreserveLength = preserveLength
            };
            try
            {
                var result = await _handler.TestHandleAsync(parameters, default);
                Assert.NotNull(result);
                Assert.True(result.Content.Length &gt; 0);
                var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
                Assert.Contains($&quot;Successfully deleted&quot;, textContent.Text);
                var actualContent = await File.ReadAllTextAsync(_testFilePath);
                Assert.Equal(expectedContent, actualContent);
            }
            finally
            {
                if (File.Exists(_testFilePath))
                    File.Delete(_testFilePath);
            }
        }
        [Theory]
        [InlineData(&quot;&quot;)]
        [InlineData(null)]
        public async Task DeleteAtPosition_WithInvalidPath_ShouldThrowArgumentException(string filePath)
        {
            var parameters = new DeleteAtPositionParameters
            {
                Operation = DeleteAtPositionOperation.DeleteAtPosition,
                Path = filePath,
                Position = 0,
                Length = 1,
                PreserveLength = false
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(-1, 5)] 
        [InlineData(0, 0)] 
        [InlineData(0, -1)] 
        public async Task DeleteAtPosition_WithInvalidParameters_ShouldThrowArgumentException(
            int position,
            int length)
        {
            await File.WriteAllTextAsync(_testFilePath, &quot;Test Content&quot;);
            var parameters = new DeleteAtPositionParameters
            {
                Operation = DeleteAtPositionOperation.DeleteAtPosition,
                Path = _testFilePath,
                Position = position,
                Length = length,
                PreserveLength = false
            };
            try
            {
                await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                    async () =&gt; await _handler.TestHandleAsync(parameters, default)
                );
            }
            finally
            {
                if (File.Exists(_testFilePath))
                    File.Delete(_testFilePath);
            }
        }
        [Fact]
        public async Task DeleteAtPosition_WithPositionBeyondFileEnd_ShouldThrowArgumentException()
        {
            var content = &quot;Short text&quot;;
            await File.WriteAllTextAsync(_testFilePath, content);
            var parameters = new DeleteAtPositionParameters
            {
                Operation = DeleteAtPositionOperation.DeleteAtPosition,
                Path = _testFilePath,
                Position = content.Length + 1, 
                Length = 5,
                PreserveLength = false
            };
            try
            {
                await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                    async () =&gt; await _handler.TestHandleAsync(parameters, default)
                );
            }
            finally
            {
                if (File.Exists(_testFilePath))
                    File.Delete(_testFilePath);
            }
        }
        [Fact]
        public async Task DeleteAtPosition_WithUnauthorizedPath_ShouldThrowUnauthorizedAccessException()
        {
            var unauthorizedPath = Path.Combine(Path.GetTempPath(), &quot;unauthorized&quot;, &quot;test.txt&quot;);
            var parameters = new DeleteAtPositionParameters
            {
                Operation = DeleteAtPositionOperation.DeleteAtPosition,
                Path = unauthorizedPath,
                Position = 0,
                Length = 5,
                PreserveLength = false
            };
            await Assert.ThrowsAsync&lt;UnauthorizedAccessException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Fact]
        public async Task DeleteAtPosition_WithInvalidOperation_ShouldThrowArgumentException()
        {
            var parameters = new DeleteAtPositionParameters
            {
                Operation = (DeleteAtPositionOperation)999, 
                Path = _testFilePath,
                Position = 0,
                Length = 5,
                PreserveLength = false
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        public void Dispose()
        {
            if (Directory.Exists(_testBasePath))
                Directory.Delete(_testBasePath, true);
        }
    }
}

</file>


<file path="mcp-toolskit-tests\TestHandlers\Filesystem\WriteFileAtPositionToolHandler.cs">

using mcp_toolskit.Handlers.Filesystem;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Server.Features.Tools;
using Moq;
namespace mcp_toolskit_tests.TestHandlers.Filesystem
{
    public class TestWriteFileAtPositionToolHandler : IDisposable
    {
        private readonly Mock&lt;IServerContext&gt; _mockServerContext;
        private readonly Mock&lt;ISessionContext&gt; _mockSessionContext;
        private readonly Mock&lt;ILogger&lt;WriteFileAtPositionToolHandler&gt;&gt; _mockLogger;
        private readonly TestAppConfig _appConfig;
        private readonly WriteFileAtPositionToolHandler _handler;
        private readonly string _testBasePath;
        private readonly object _lock = new object();
        public class TestAppConfig : AppConfig
        {
            public override string ValidatePath(string path)
            {
                return Path.GetFullPath(path);
            }
        }
        public TestWriteFileAtPositionToolHandler()
        {
            _testBasePath = Path.Combine(Path.GetTempPath(), &quot;mcp-toolskit-tests&quot;, Guid.NewGuid().ToString().Replace(&quot;-&quot;,&quot;&quot;));
            _mockServerContext = new Mock&lt;IServerContext&gt;();
            _mockSessionContext = new Mock&lt;ISessionContext&gt;();
            _mockLogger = new Mock&lt;ILogger&lt;WriteFileAtPositionToolHandler&gt;&gt;();
            _appConfig = new TestAppConfig();
            _handler = new WriteFileAtPositionToolHandler(
                _mockServerContext.Object,
                _mockSessionContext.Object,
                _mockLogger.Object,
                _appConfig
            );
            EnsureDirectoryExists(_testBasePath);
        }
        private void EnsureDirectoryExists(string path)
        {
            lock (_lock)
            {
                if (!Directory.Exists(path))
                {
                    Directory.CreateDirectory(path);
                }
            }
        }
        private void CleanupDirectory(string path)
        {
            lock (_lock)
            {
                if (Directory.Exists(path))
                {
                    try 
                    {
                        Directory.Delete(path, true);
                    }
                    catch (IOException)
                    {
                        Thread.Sleep(100);
                        if (Directory.Exists(path))
                        {
                            Directory.Delete(path, true);
                        }
                    }
                }
            }
        }
        private string GetTestPath(string filename)
        {
            var path = Path.Combine(_testBasePath, filename);
            EnsureDirectoryExists(Path.GetDirectoryName(path));
            return path;
        }
        [Theory]
        [InlineData(&quot;test.txt&quot;, &quot;Hello&quot;, 0, &quot;Hello world&quot;, &quot;Hello world&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;totos&quot;, 0, &quot;Hello world&quot;, &quot;totos world&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot; world&quot;, 5, &quot;Hello&quot;, &quot;Hello world&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Test&quot;, 10, &quot;Hello&quot;, &quot;Hello     Test&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot; awesome&quot;, 5, &quot;Hello world!&quot;, &quot;Hello awesome world!&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot; &quot;, 6, &quot;Hello!&quot;, &quot;Hello! &quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;New&quot;, 0, &quot;&quot;, &quot;New&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Middle&quot;, 7, &quot;1234567890&quot;, &quot;1234567Middle890&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Extra&quot;, 0, &quot;Extra&quot;, &quot;Extra&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Padding&quot;, 3, &quot;ABCDEF&quot;, &quot;ABCPaddingDEF&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Append&quot;, 10, &quot;Existing&quot;, &quot;Existing  Append&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Multi&quot;, 3, &quot;A B C D E F&quot;, &quot;A BMulti C D E F&quot;)] 
        [InlineData(&quot;test.txt&quot;, &quot;Special!&quot;, 3, &quot;Chars~@$#&quot;, &quot;ChaSpecial!rs~@$#&quot;)] 
        public async Task WriteFileAtPosition_ShouldWriteContentCorrectly(string filename, string content, int position, string initialContent, string expectedFinalContent)
        {
            await Task.Delay(100);  
            var filePath = GetTestPath(filename);
            if (!string.IsNullOrEmpty(initialContent))
            {
                await File.WriteAllTextAsync(filePath, initialContent);
            }
            var parameters = new WriteFileAtPositionParameters
            {
                Operation = WriteFileAtPositionOperation.WriteFileAtPosition,
                Path = filePath,
                Content = content,
                Position = position
            };
            try
            {
                var result = await _handler.TestHandleAsync(parameters, default);
                Assert.NotNull(result);
                Assert.True(result.Content.Length &gt; 0);
                var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
                Assert.Contains($&quot;Successfully wrote content at position {position} in {filePath}&quot;, textContent.Text);
                var actualContent = await File.ReadAllTextAsync(filePath);
                Assert.Equal(expectedFinalContent, actualContent);
            }
            finally
            {
                if (File.Exists(filePath))
                {
                    try
                    {
                        File.Delete(filePath);
                    }
                    catch (IOException)
                    {
                    }
                }
            }
        }
        [Theory]
        [InlineData(&quot;&quot;)]
        [InlineData(null)]
        public async Task WriteFileAtPosition_WithInvalidPath_ShouldThrowArgumentException(string filePath)
        {
            var parameters = new WriteFileAtPositionParameters
            {
                Operation = WriteFileAtPositionOperation.WriteFileAtPosition,
                Path = filePath,
                Content = &quot;Test content&quot;,
                Position = 0
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(&quot;test.txt&quot;, &quot;&quot;, 0)]
        [InlineData(&quot;test.txt&quot;, null, 0)]
        public async Task WriteFileAtPosition_WithInvalidContent_ShouldThrowArgumentException(string filename, string content, int position)
        {
            var filePath = GetTestPath(filename);
            var parameters = new WriteFileAtPositionParameters
            {
                Operation = WriteFileAtPositionOperation.WriteFileAtPosition,
                Path = filePath,
                Content = content,
                Position = position
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Fact]
        public async Task WriteFileAtPosition_WithNegativePosition_ShouldThrowArgumentException()
        {
            var filePath = GetTestPath(&quot;test.txt&quot;);
            var parameters = new WriteFileAtPositionParameters
            {
                Operation = WriteFileAtPositionOperation.WriteFileAtPosition,
                Path = filePath,
                Content = &quot;Test content&quot;,
                Position = -1
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Fact]
        public async Task WriteFileAtPosition_WithInvalidOperation_ShouldThrowArgumentException()
        {
            var filePath = GetTestPath(&quot;test.txt&quot;);
            var parameters = new WriteFileAtPositionParameters
            {
                Operation = (WriteFileAtPositionOperation)999, 
                Path = filePath,
                Content = &quot;Test content&quot;,
                Position = 0
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        public void Dispose()
        {
            CleanupDirectory(Path.Combine(Path.GetTempPath(), &quot;mcp-toolskit-tests&quot;));
        }
    }
}

</file>


<file path="mcp-toolskit-tests\TestHandlers\TestCalculatorToolHandler.cs">

using mcp_toolskit.Handlers;
using mcp_toolskit.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.NET.Server.Contexts;
using ModelContextProtocol.NET.Core.Models.Protocol.Shared.Content;
using ModelContextProtocol.NET.Core.Models.Protocol.Common;
using ModelContextProtocol.NET.Server.Features.Tools;
using Moq;
namespace mcp_toolskit_tests.TestHandlers
{
    public class TestCalculatorToolHandler
    {
        private readonly Mock&lt;IServerContext&gt; _mockServerContext;
        private readonly Mock&lt;ISessionContext&gt; _mockSessionContext;
        private readonly Mock&lt;ILogger&lt;CalculatorToolHandler&gt;&gt; _mockLogger;
        private readonly CalculatorToolHandler _handler;
        public TestCalculatorToolHandler()
        {
            _mockServerContext = new Mock&lt;IServerContext&gt;();
            _mockSessionContext = new Mock&lt;ISessionContext&gt;();
            _mockLogger = new Mock&lt;ILogger&lt;CalculatorToolHandler&gt;&gt;();
            _handler = new CalculatorToolHandler(
                _mockServerContext.Object,
                _mockSessionContext.Object,
                _mockLogger.Object
            );
        }
        [Theory]
        [InlineData(2, 3, 5)]
        [InlineData(-1, 1, 0)]
        [InlineData(0, 0, 0)]
        public async Task Add_ShouldReturnCorrectSum(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Add,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            Assert.True(result.Content.Length &gt; 0);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(5, 3, 2)]
        [InlineData(10, -5, 15)]
        [InlineData(0, 0, 0)]
        public async Task Subtract_ShouldReturnCorrectDifference(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Subtract,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(4, 2, 8)]
        [InlineData(-3, -2, 6)]
        [InlineData(0, 5, 0)]
        public async Task Multiply_ShouldReturnCorrectProduct(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Multiply,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(10, 2, 5)]
        [InlineData(-8, 2, -4)]
        [InlineData(0, 5, 0)]
        public async Task Divide_ShouldReturnCorrectQuotient(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Divide,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(10, 0)]
        public async Task Divide_ByZero_ShouldThrowException(double a, double b)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Divide,
                A = a,
                B = b
            };
            await Assert.ThrowsAsync&lt;DivideByZeroException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(2, 3, 8)]
        [InlineData(5, 2, 25)]
        [InlineData(0, 5, 0)]
        public async Task Power_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Power,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(16, 0, 4)]
        [InlineData(9, 0, 3)]
        [InlineData(0, 0, 0)]
        public async Task SquareRoot_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.SquareRoot,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(-1)]
        public async Task SquareRoot_NegativeNumber_ShouldThrowException(double a)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.SquareRoot,
                A = a,
                B = 0
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(10, 3, 1)]
        [InlineData(17, 5, 2)]
        public async Task Modulo_ShouldReturnCorrectRemainder(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Modulo,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(10, 0)]
        public async Task Modulo_ByZero_ShouldThrowException(double a, double b)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Modulo,
                A = a,
                B = b
            };
            await Assert.ThrowsAsync&lt;DivideByZeroException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(-5, 0, 5)]
        [InlineData(3.5, 0, 3.5)]
        [InlineData(0, 0, 0)]
        public async Task Abs_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Abs,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(Math.E, Math.E, 1)]
        [InlineData(8, 2, 3)]
        public async Task Log_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Log,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(-1, 2)]
        [InlineData(0, 2)]
        public async Task Log_InvalidInput_ShouldThrowException(double a, double b)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Log,
                A = a,
                B = b
            };
            await Assert.ThrowsAsync&lt;ArgumentException&gt;(
                async () =&gt; await _handler.TestHandleAsync(parameters, default)
            );
        }
        [Theory]
        [InlineData(0, 0, 0)]
        [InlineData(Math.PI / 2, 0, 1)]
        [InlineData(Math.PI, 0, 0)]
        public async Task Sin_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Sin,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(Math.Round(expected, 10).ToString(), Math.Round(double.Parse(textContent.Text), 10).ToString());
        }
        [Theory]
        [InlineData(0, 0, 1)]
        [InlineData(Math.PI / 2, 0, 0)]
        [InlineData(Math.PI, 0, -1)]
        public async Task Cos_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Cos,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(Math.Round(expected, 10).ToString(), Math.Round(double.Parse(textContent.Text), 10).ToString());
        }
        [Theory]
        [InlineData(0, 0, 0)]
        [InlineData(Math.PI / 4, 0, 1)]
        public async Task Tan_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Tan,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(Math.Round(expected, 10).ToString(), Math.Round(double.Parse(textContent.Text), 10).ToString());
        }
        [Theory]
        [InlineData(3.7, 0, 4)]
        [InlineData(-3.7, 0, -4)]
        [InlineData(3.2, 0, 3)]
        public async Task Round_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Round,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
        [Theory]
        [InlineData(3.7, 0, 3)]
        [InlineData(-3.7, 0, -4)]
        [InlineData(3.2, 0, 3)]
        public async Task Floor_ShouldReturnCorrectResult(double a, double b, double expected)
        {
            var parameters = new CalculatorParameters
            {
                Operation = CalculatorOperation.Floor,
                A = a,
                B = b
            };
            var result = await _handler.TestHandleAsync(parameters, default);
            Assert.NotNull(result);
            var textContent = Assert.IsType&lt;TextContent&gt;(result.Content[0]);
            Assert.Equal(expected.ToString(), textContent.Text);
        }
    }
}

</file>


</solution>
